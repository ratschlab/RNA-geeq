"""This script gets a bed file generated with FluxSimulator as well as genome and error_model and creates reads with qualities and store their optimal alignment. """


import pickle
import random
import sys
import os
import re
import pdb
import genome_utils

def parse_options(argv):

    """Parses options from the command line """

    from optparse import OptionParser, OptionGroup

    parser = OptionParser()
    required = OptionGroup(parser, 'REQUIRED')
    required.add_option('-q', '--qualities', dest='qualities', metavar='FILE', help='read qualities, e.g., generated by create_quality_sample.sh', default='-')
    required.add_option('-f', '--fasta', dest='fasta', metavar='FILE', help='file storing the reads created with parse_reads_from_gff.py', default='-')
    required.add_option('-m', '--mismatch', dest='mismatch', metavar='FILE', help='the output of mismatch.py according to which reads are \
                        mutated based on nucleotide composition and qualities', default='-')
    required.add_option('-o', '--optimal', dest='optimal', metavar='FILE', help='will store the optimal alignment of reads in fasta to the genome in genome.config', default='-')
    optional = OptionGroup(parser, 'OPTIONAL')
    optional.add_option('-s', '--simple', dest='simple', action='store_true', help='does not create optimal alignment, cannot simulate deletions', default=False)
    required.add_option('-b', '--bed', dest='bed', metavar='FILE', help='use given bed in stead of logfile', default='-')
    optional.add_option('-p', '--paired', dest='paired', action='store_true', help='generates paired optimal alignments, needs paired input reads', default=False)
    optional.add_option('-P', '--skip-polya', dest='skip_polya', action='store_true', help='skips polyA reads', default=False)
    optional.add_option('-g', '--generrors', dest='generrors', action='store_false', help='introduce mutations [ default: set ]', default=True)
    required.add_option('-G', '--genome', dest='genome', metavar='FILE', help='genome information file for reconstructing genomic information', default='-')
    optional.add_option('-e', '--errorinfo', dest='errorinfo', action='store_true', help='show error info in created read [ default: not set ]', default=False)
    optional.add_option('-v', '--verbose', dest='verbose', action='store_true', help='verbosity', default=False)
    optional.add_option('-F', '--force_deletions', dest='force_deletions', action='store_true', help='forces deletions in simple mode [ default: not set ]', default=False)
    optional.add_option('-i', '--insertprob', dest='p_insert', metavar='FLOAT', help='probability for an insertion during a mutation [ default: 0.05 ]', type='float', default=0.05)
    optional.add_option('-n', '--noise', dest='noise', metavar='FLOAT', help='probability that an unmutated position will be mutated nevertheless [ default: 0.0 ]', type='float', default=0.0)
    parser.add_option_group(required)
    parser.add_option_group(optional)

    (options, args) = parser.parse_args()
    
    if (options.simple and len(argv) < 4) or (not options.simple and (len(argv) < 6 or options.p_insert > 1.0 or options.noise > 1.0 or '-' in [options.fasta, options.mismatch, options.optimal])):
        parser.print_help()
        sys.exit(2)

    return options

def mutate_read(ql, fl, qualities, substitutions, mismatches, options):
    """Inserting mutations based on quality line and error model."""

    read = ''
    logread = ''
    qual = '' 

    for i in xrange(len(ql) - 1):
        
        options.positions += 1

        q = ql[i]
        f = fl[i].upper()
        try:
            (a, b) = qualities[(f, q)]
        except KeyError:
            a = 0
            b = 1
        if options.generrors and random.uniform(0, 1) < (float(a)/float(b) * (1.0 - options.noise)) + options.noise and random.uniform(0, 1) < options.p_insert:
            cum = 0
            p = random.uniform(0, 1)
            denom = 0
            for s in ('A', 'C', 'G', 'T', 'N', '-'):
                try:
                    denom += substitutions[('-', s)]
                except KeyError:
                    pass

            for s in ('A', 'C', 'G', 'T', 'N', '-'):
                try:
                    cum += substitutions[('-', s)]
                except KeyError:
                    pass
                if denom > 0 and p < cum / float(denom):
                    if s == '-':
                        c = ''
                        lr = ''
                    else:
                        if options.errorinfo == 1:
                            c = '[-' + s + ']'
                        else:
                            c = s
                        lr = '[-' + s + ']'
                        options.insertions += 1
                        options.mutated_positions += 1
                    break
            read += c
            qual += ql[i] 
            logread += lr

        q = ql[i]
        f = fl[i].upper()
        try:
            (a, b) = qualities[(f, q)]
        except KeyError:
            a = 0
            b = 1

        c = f
        lr = f
        if options.generrors and random.uniform(0, 1) < (float(a) / float(b) * (1.0 - options.noise)) + options.noise :
            cum = 0
            p = random.uniform(0, 1)
            denom = 0

            for s in options.sample_source:
                try:
                    denom += substitutions[(f, s)]
                except KeyError:
                    pass

            for s in options.sample_source:
                try:
                    cum += substitutions[(f, s)]
                except KeyError:
                    pass
                if denom > 0 and p < cum / float(denom):
                    if s == '-':
                        if options.errorinfo == 1:
                            c = '[' + f + '-]'
                        else:
                            c = ''
                        q = '' 
                        lr = '[' + f + '-]'
                        options.deletions += 1
                    else:
                        if options.errorinfo == 1:
                            c = '[' + f + s + ']'
                        else:
                            c = s
                        lr = '[' + f + s + ']'
                    mismatches[(f, s)] += 1
                    if f != s:
                        options.mutated_positions += 1
                    break
        
        read += c
        qual += q 
        logread += lr

    assert(len(qual) == len(read))

    return (read, logread, qual)


def main(options):
    """Function controlling the main program flow."""
    
    ((qualities, substitutions), dummy) = pickle.load(file(options.mismatch))

    if not (options.qualities == '-'):
        qfile = file(options.qualities)
        
    ffile = file(options.fasta)

    if options.simple and not options.force_deletions:
        bed = sys.stdin
        options.sample_source = ('A', 'C', 'G', 'T', 'N')
    else:
        if options.bed != '-':
            bed = open(options.bed, 'r')
        else:
            print >> sys.stderr, "\nERROR: No BED file given!\n"
            sys.exit(2)
        options.sample_source = ('A', 'C', 'G', 'T', 'N', '-')
        
    ### initialize counters
    options.positions = 0
    options.mutated_positions = 0
    options.deletions = 0
    options.insertions = 0
    mismatches = dict()
    line_counter = 0
    extend_counter = 0
    for i in options.sample_source:
        for j in options.sample_source:
            mismatches[(i, j)] = 0

    ### open file streams
    opt = open(options.optimal, 'w')

    fh = ffile.readline()
    fl = ffile.readline()
    if options.paired:
        fh_2 = ffile.readline()
        fl_2 = ffile.readline()
   
    initial_len = len(fl.strip())

    ### init quality line list
    if (options.qualities == '-'):
        qlist = ['h' * len(fl)] 
    else:    
        ql = qfile.readline()
        qlist = [ql]
        while ql:
            ql = qfile.readline()
            if len(ql)>10:
                qlist.append(ql)

    ### init bed_line and genome
    if not options.simple:
        bed_line = bed.readline().strip().split('\t')
        if options.paired:
            bed_line2 = bed.readline().strip().split('\t')
        else:
            bed_line2 = ['']

        if options.genome != '-':
            ### parse genome file
            gio = genome_utils.GenomeInfo(options.genome)
            gio.contig_names.sort()
            genome = dict()
        else:
            print >> sys.stderr, "No genome given!"
            
    random.seed(os.urandom(128))
    process_second = False

    while fh and fl and bed and (not options.paired or (fh_2 and fl_2)):
        ql = qlist[random.randint(0, len(qlist)-1)]
        if options.verbose and line_counter % 10000 == 0:
            print >> sys.stderr, '%s lines processed' % line_counter
    
        ### skip polyA reads
        if options.skip_polya:
            while not options.simple and 'polyA' in [bed_line[0], bed_line2[0]]:
                if options.paired and bed_line[0] != bed_line2[0]:
                    # TODO - this for sure does not work
                    fh = ffile.readline()
                    fl = ffile.readline()
                    (fh, fh_2) = (fh_2, fh)
                    (fl, fl_2) = (fl_2, fl)
                bed_line = bed.readline().strip().split('\t')
                fh = ffile.readline()
                fl = ffile.readline()
                if options.paired:
                    bed_line2 = bed.readline().strip().split('\t')
        
        if '' in [fh, fl, bed_line] or (options.paired and '' in [fh_2, fl_2, bed_line2]):
            break

        line_counter += 1
        
        ### extend quality line if neccessary
        extended = False
        while len(ql) < len(fl):
            ql = ql[:(len(ql)) / 2 + 1] + ql[len(ql) / 2:]
            extended = True
        if extended:
            extend_counter += 1
        if len(ql) > len(fl):
            ql = ql[:len(fl)]

        print '@' + fh[1:].strip()

        if not options.simple and len(bed_line) < 2:
            break
        ql = ql.strip()
        fl = fl.strip()
        
        ### mutate read 
        (read, logread, qual) = mutate_read(ql, fl, qualities, substitutions, mismatches, options)

        mutation_gap = initial_len - len(read)

        ### read too long? --> handle insertions
        while len(read) > initial_len:
            if options.errorinfo == 1 and read[-1] == ']':
                read = read[:-4]
            else:
                if re.search('\[.-\]', logread[-4:]) == None:
                    read = read[:-1]
                    qual = qual[:-1]
            if logread[-1] == ']':
                if re.search('\[.-\]', logread[-4:]) != None:
                    options.deletions -= 1
                logread = logread[:-4]
            else:
                logread = logread[:-1]

        while re.search('\[.-\]', logread[-4:]) != None:
            options.deletions -= 1
            logread = logread[:-4]

        if not options.simple:
            ### read too short? --> handle deletions
            if len(read) < initial_len:
                gap = initial_len - len(read)
                if options.genome != '-':
                    _chrm = bed_line[0]
                    _chrm = _chrm.replace('chr', '')
                    # load sequence
                    if not genome.has_key(_chrm):
                        if _chrm in gio.contig_names:
                            fgen = open('%s/genome/%s.flat' % (gio.basedir, _chrm))
                            genome[_chrm] = fgen.readline()
                            fgen.close()
                        else:       
                            print >> sys.stderr, 'Chromosome Names do not match genome information file. Chromosome %s can not be found!' % _chrm
                            exit(2)
                     # define offsets
                    _offsets = bed_line[11].strip().split(',') # block starts (relative genomic position)
                    _sizes = bed_line[10].strip().split(',') # block sizes
                    _start = int(bed_line[1]) + int(_offsets[-1]) + int(_sizes[-1]) # genome_start + last rel block start + last block size
                    # there are different appendizes for + and - strand
                    if bed_line[5] == '-':
                        appendix = genome_utils.reverse_complement(genome[_chrm][max(int(bed_line[1]) - gap, 0) : int(bed_line[1])].upper())
                    else:
                        appendix = genome[_chrm][_start : min(_start + gap, len(genome[_chrm]))].upper()
                    if len(appendix) < gap:
                        appendix += (len(appendix) - gap) * 'N'
                    read += appendix
                    logread += appendix
                qual += gap*qual[-1]

        log_with_errorinfo = logread

        # print reads in fastq format 
        print read.strip()
        print '+' #+ fh[1:].strip()
        print qual.strip()

        if not options.simple:
            # create optimal alignment
            pos = bed_line[11].split(',')
            pos = [int(i) + int(bed_line[1]) for i in pos]
            sizes = bed_line[10].split(',')
            sizes = [int(i) for i in sizes]
            sizes[-1] += mutation_gap
            while sizes[-1] < 1:
                sizes[-2] += sizes[-1]
                del sizes[-1]

            # generate CIGAR
            _cigar = ''
            p = 0
            while p < len(log_with_errorinfo):
                if log_with_errorinfo[p] != '[':
                    _cigar += 'M'
                    p += 1
                else:
                    if log_with_errorinfo[p + 1] == '-':
                        _cigar += 'I'
                    elif log_with_errorinfo[p + 2] == '-':
                        _cigar += 'D'
                    else:
                        _cigar += 'M'
                    p += 4

            _c = 0
            __cigar = ''
            _last = _cigar[0]
            _cum_sizes = [sizes[0]]
            for p in range(1, len(sizes)):
                _cum_sizes.append(_cum_sizes[p - 1] + sizes[p])

            p = 0
            gen_pos = 0
            cig_op = []
            cig_size = []
            _pos = pos
            for cig_pos in range(len(_cigar)):
                if _cigar[cig_pos] == _last:
                    _c += 1
                else:
                    if _c > 0:
                        cig_op.append(_last)
                        cig_size.append(_c)
                    _c = 1
                    _last = _cigar[cig_pos]
                if _last != 'I':
                    gen_pos += 1

                if len(_cum_sizes) > 1 and gen_pos == _cum_sizes[0]:
                    if _c > 0:
                        cig_op.append(_last)
                        cig_size.append(_c)
                    _c = 0
                    cig_op.append('N')
                    cig_size.append(_pos[1] - _pos[0] - sizes[0])
                    sizes = sizes[1:]
                    _cum_sizes = _cum_sizes[1:]
                    _pos = _pos[1:]

            cig_op.append(_last)
            cig_size.append(_c)

            ### check CIGAR for doubled/deleted blocks
            del_idx = []
            if len(cig_op) > 2:
                for op in range(1, len(cig_op) - 1):
                    if cig_op[op] == 'D' and cig_op[op - 1] == 'N' and cig_op[op + 1] == 'N':
                        cig_size[op + 1] += (cig_size[op -1] + cig_size[op])
                        del_idx.append(op - 1)
                        del_idx.append(op)
                            
            for op in sorted(del_idx, reverse=True):
                del cig_size[op]
                del cig_op[op]
            
            __cigar = ''
            for op in range(len(cig_size)):
                __cigar += (str(cig_size[op]) + cig_op[op])

            # adapt starting position in case of deletions
            if cig_op[0] == 'D':
                pos[0] += cig_size[0]
                cig_op[0] = 'H'
            if cig_op[-1] == 'D':
                cig_op[-1] = 'H'
            if cig_op[0] == 'I':
                cig_op[0] = 'S'
            if cig_op[-1] == 'I':
                cig_op[-1] = 'S'
 
            ## write optimal alignment in SAM format
            tempstr = ''
            # read_id
            tempstr += (bed_line[3] + '\t')
            # flag
            if options.paired:
                _flag = 3 # paired in sequencing and mapped as pair
            else:
                _flag = 0
            if bed_line[5] == '-':
                _flag += 16
            tempstr += (str(_flag) + '\t')

            # chromosome
            tempstr += (bed_line[0] + '\t')
            # start pos
            tempstr += (str(pos[0] + 1) + '\t')
            # mapping quality
            tempstr += '255\t'
            tempstr += (__cigar + '\t')

            # MateRefName
            tempstr += '=\t'
            # Mate start pos
            if options.paired:
                tempstr += (bed_line2[0] + '\t')
            else:
                tempstr += '*\t'
            # insert size
            tempstr += '*\t'
            # sequence and quality
            if _flag & 16 == 16:
                tempstr += (genome_utils.reverse_complement(read.strip()).upper() + '\t')
                tempstr += (qual.strip()[::-1] + '\t')
            else:
                tempstr += (read.strip().upper() + '\t')
                tempstr += (qual.strip() + '\t')

            print >> opt, tempstr[:-1]

        process_second = not process_second
        if options.paired and process_second:
            (fh, fh_2) = (fh_2, fh)
            (fl, fl_2) = (fl_2, fl)
            (bed_line, bed_line2) = (bed_line2, bed_line)
        else:
            fh = ffile.readline()
            fl = ffile.readline()
            if options.paired:
                fh_2 = ffile.readline()
                fl_2 = ffile.readline()
            if not options.simple:
                bed_line = bed.readline().strip().split('\t')
                if options.paired:
                    bed_line2 = bed.readline().strip().split('\t')

    opt.close()

    ### print mutation overview
    print >> sys.stderr, 'mutated %s out of %s positions \n' % (options.mutated_positions, options.positions)
    print >> sys.stderr, 'deletions: %s' % options.deletions
    print >> sys.stderr, 'insertions: %s' % options.insertions
    _line = '\t'
    for i in options.sample_source: 
        _line += (str(i) + '\t')
    print >> sys.stderr, _line[:-1]
    for i in options.sample_source: 
        _line = (str(i) + '\t')
        for j in options.sample_source:
            _line += (str(mismatches[(i, j)]) + '\t')
        print >> sys.stderr, _line
    print >> sys.stderr, 'extended %i quality lines' % extend_counter

if __name__ == '__main__':
    main(parse_options(sys.argv))
